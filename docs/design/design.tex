\documentclass{article}

\usepackage{sectsty}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}

\begin{document}

% title stuff
\title{Interactive Fractal Viewer \\
CSEE W4840 Project Design}
\author{Luis E. P. - lep2141@columbia.edu \and
Nathan Hwang - nyh2105@columbia.edu \and
Stephen Pratt - sdp2128@columbia.edu \and
Richard Nwaobasi - rcn2105@columbia.edu}
\maketitle

\abstract{In order to display beautiful fractals more efficiently, we
  utilize specialized hardware to calculate a quadratic polynomial
  Julia set. Using fixed point calculations within logic blocks
  executing in parallel, we display the resulting Julia set from a
  framebuffer, mapped from iteration to RGB space.}

% ------------------------------------------------------------
% and we begin the design document proper

Everyone loves fractals! We can display them efficiently using
specialized hardware. 


% ------------------------------------------------------------
\section{High-level Overview}

Here we would talk about the high-level block structure of the project:

\begin{itemize}
\item Nios II CPU acts as the dispatcher
\item This writes to a queue, which feeds values to Iterated function
  modules (IFM)
\item Multiple IFMs calculate the number of iterations originating at
  a certain pixel (which maps to a certain point on the imaginary
  plane)
\item Another queue recieves the results from the IFMs, and passes
  them to the framebuffer
\item The VGA module fetches results from the framebuffer, and
  colorizes the pixels as they pass.
\end{itemize}

% !!! HAVE KICKASS DRAWING OF BLOCK DIAGRAM HERE



% ------------------------------------------------------------
% now, we delve into the lower levels of the implementation
% ------------------------------------------------------------
\section{Critical Modules}

These are very important. There is a reason why these modules are
called critical.

% ----------------------------------------
\subsection{Generator Module}

The generator module serves to kick off the calculation cascade,
calculating the position of each pixel in the complex plane and
writing both to active memory linked up to the input queue (described
below).

In more detail, the module loops through each pixel given the screen
resolution, and maps it according to the translation of the origin as
well as the scale of the complex plane with respect to the VGA
screen. Since we may yet implement the translation of the origin as a
parameter mutable by the user, this seperation of concerns makes
sense.

We switched this module from a hardware implementation to code sitting
on top of the \verb!Nios II! processor.

This was partly because having all that pain from lab 3 go to waste
didn't seem very useful, and 

Implementation-wise, the Nios II processor is the ``economy'' model,
the \verb!Nios II/e!. It relies on the addition provided by the C
processor, and takes advantage of the provided Altera fabric to
communicate with the input queue that sits in front of the IFMs.

The Nios II accepts the SDRAM as it's memory store, since we use the
SRAM below as the framebuffer.

% ----------------------------------------
\subsection{Iterated Function Module (IFM)}

Calculating the popular Mandelbrot and Julia set fractals requires
many iterations of relatively simple computations. This alone implies
that the calculation of fractal sets lends itself to parallel
computation, but the very nature of the iterated fractal calculation
means that the run lengths of the individual calculations are
heterogenous, introducing synchronization issues.

With a pair of queues handling the heterogenity of the fractal
calculations, the IFM merely need calculate applications of the function:

\begin{equation}
f(z) = z^2 + c
\end{equation}

over and over again, where $z,c \in \mathbb{C}$.

% !!! I start to lose coherency right about here

The complex nature of the calculations means that there need be 3
multiplications, not just 1, to find the next iteration of $z$.

We count 127 iterations: after the 127th iteration, we consider the
originating point bounded.

We restrict ourselves to 18 bits, since the multipliers on board the
chip are sized such.

We use fixed point, because floating point is slow and fixed point
proved ``good enough'' when we did a proof-of-concept with limited bit
widths with C programs.

We pass a pixel position and point on the complex plane to the IFM
through the queue, since the complex plane position is meant to
facilitate the fractal calculation and the pixel position is meant for
display on the screen.

% ----------------------------------------
\subsection{Queues}

We hold these opinions to be true:

\begin{itemize}
\item Multiple IFMs can and should work in parallel
\item The processing time for each pixel varies
\end{itemize}

Hence, we implement a pair of queues to wrap the IFM pool, who
allocate and gather the work as IFMs become available and finish.

% !!! I DON'T KNOW HOW THIS IS IMPLEMENTED


% ----------------------------------------
\subsection{Frame Buffer}

We store the iteration counts in the SRAM external to the chip, which
serves as the framebuffer. 

640x480x8

Using a nice addressing scheme, the addresses get passed straight through.

Stored as iteration counts: the color conversion happens in the VGA
module, on the fly.


% ----------------------------------------
\subsection{VGA Module}

We use something akin to the VGA-portion of Lab 3, while colorizing
the pixels fetched from the framebuffer.

The colorization method is essentially a fancy decoder.

Colorization module takes each value from the ID Buffer, applies the
colorization function $k$ to the value, and displays the resulting RGB
value $k(n)$.


% ------------------------------------------------------------
\section{Parametrization Modules}

Time permitting their implementation, these modules can modulate the
output in interesting ways.

\begin{itemize}
\item The Seed Module maps switch configurations to a Julia Set
  constant $c$. The module must communicate this value to each IFM, and
  ask the generator module for a remapping.
\item Display selection module determines the $x$ range and $y$ range of
  the display window.  The module must communicate these ranges to the
  generator module and ask for a remapping.
\item K-selector module cycles through colorization functions and
  reports the function to the colorization module.
\item Spectral analysis module takes audio input and uses it to effect
  the performance of the k-selector module.
\end{itemize}


% ------------------------------------------------------------
% !!! UPDATE MILESTONES IF NECESSARY
\section{Updated Milestones}

\begin{itemize}
\item Milestone 1 (Mar 27): \\
  Have a static Julia set filled into the ID buffer.
\item Milestone 2 (Apr 10): \\
  Display the colorized (and static) Julia set through VGA.
\item Milestone 3 (Apr 24): \\ 
  Implement parameter changing, with
  subsequent updates to the displayed Julia set.
\end{itemize}

\end{document}
